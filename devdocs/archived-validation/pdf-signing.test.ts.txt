/**
 * elaraSign PDF Signing - Real File Test
 * =======================================
 * 
 * Tests PDF signing against actual PDF files, not fake stubs.
 * 
 * Run with: npx tsx src/core/pdf-signing.test.ts
 */

import { PDFDocument, StandardFonts } from 'pdf-lib';
import {
  signPdf,
  verifyPdf,
  hasPdfSignature,
  sha256,
  type PdfSigningMetadata,
} from './pdf-signing.js';
import * as fs from 'node:fs';
import * as path from 'node:path';

// ============================================================================
// Test Helper: Create a REAL PDF with pdf-lib
// ============================================================================

async function createRealPdf(title: string, content: string): Promise<Uint8Array> {
  const pdf = await PDFDocument.create();
  
  // Set initial metadata
  pdf.setTitle(title);
  pdf.setAuthor('Test Author');
  pdf.setCreator('Test Creator');
  
  // Add a page with actual content
  const page = pdf.addPage([612, 792]); // Letter size
  const font = await pdf.embedFont(StandardFonts.Helvetica);
  
  page.drawText(content, {
    x: 50,
    y: 700,
    size: 12,
    font,
  });
  
  page.drawText(`Generated: ${new Date().toISOString()}`, {
    x: 50,
    y: 680,
    size: 10,
    font,
  });
  
  return await pdf.save();
}

// ============================================================================
// Tests
// ============================================================================

async function runTests() {
  console.log('ðŸ§ª elaraSign PDF Signing - Real File Tests\n');
  console.log('='.repeat(60));
  
  let passed = 0;
  let failed = 0;
  
  // ------------------------------------------------------------------------
  // Test 1: Create and sign a real PDF
  // ------------------------------------------------------------------------
  console.log('\nðŸ“„ Test 1: Sign a real PDF document');
  
  try {
    const pdfBytes = await createRealPdf(
      'Test Document',
      'This is a test PDF document for elaraSign testing.'
    );
    
    console.log(`   Original PDF size: ${pdfBytes.length} bytes`);
    
    const metadata: PdfSigningMetadata = {
      method: 'ai',
      generator: 'test-suite',
      model: 'gpt-4-turbo',
      generatedAt: new Date().toISOString(),
      userFingerprint: 'test-user-fingerprint-abc123',
    };
    
    const result = await signPdf(pdfBytes, metadata);
    
    console.log(`   Signed PDF size: ${result.signedPdf.length} bytes`);
    console.log(`   Content hash: ${result.contentHash.slice(0, 16)}...`);
    console.log(`   Signature hash: ${result.signatureHash.slice(0, 16)}...`);
    
    // Verify the signed PDF is valid
    const verifyPdfLib = await PDFDocument.load(result.signedPdf);
    const pageCount = verifyPdfLib.getPageCount();
    
    if (result.signedPdf.length > pdfBytes.length &&
        result.signatureHash.length === 64 &&
        pageCount === 1) {
      console.log('   âœ… PASSED: PDF signed successfully');
      passed++;
    } else {
      console.log('   âŒ FAILED: Invalid signing result');
      failed++;
    }
  } catch (e) {
    console.log(`   âŒ FAILED: ${e}`);
    failed++;
  }
  
  // ------------------------------------------------------------------------
  // Test 2: Verify signed PDF - check all layers
  // ------------------------------------------------------------------------
  console.log('\nðŸ“„ Test 2: Verify signed PDF metadata');
  
  try {
    const pdfBytes = await createRealPdf('Verification Test', 'Testing verification.');
    
    const metadata: PdfSigningMetadata = {
      method: 'human',
      generator: 'manual-upload',
      generatedAt: '2026-01-11T12:00:00.000Z',
      userFingerprint: 'verify-test-fp',
      model: 'none',
    };
    
    const { signedPdf, signatureHash } = await signPdf(pdfBytes, metadata);
    const verification = await verifyPdf(signedPdf);
    
    console.log(`   isSigned: ${verification.isSigned}`);
    console.log(`   layersFound.infoDict: ${verification.layersFound.infoDict}`);
    console.log(`   layersFound.customProps: ${verification.layersFound.customProps}`);
    console.log(`   layersFound.keywords: ${verification.layersFound.keywords}`);
    console.log(`   method: ${verification.metadata?.method}`);
    console.log(`   generator: ${verification.metadata?.generator}`);
    
    if (verification.isSigned &&
        verification.layersFound.infoDict &&
        verification.layersFound.customProps &&
        verification.layersFound.keywords &&
        verification.metadata?.method === 'human' &&
        verification.metadata?.generator === 'manual-upload' &&
        verification.signatureHash?.startsWith(signatureHash.slice(0, 16))) {
      console.log('   âœ… PASSED: All layers verified');
      passed++;
    } else {
      console.log('   âŒ FAILED: Verification mismatch');
      console.log('   Full result:', JSON.stringify(verification, null, 2));
      failed++;
    }
  } catch (e) {
    console.log(`   âŒ FAILED: ${e}`);
    failed++;
  }
  
  // ------------------------------------------------------------------------
  // Test 3: hasPdfSignature detection
  // ------------------------------------------------------------------------
  console.log('\nðŸ“„ Test 3: hasPdfSignature detection');
  
  try {
    const unsignedPdf = await createRealPdf('Unsigned', 'This PDF is not signed.');
    const signedResult = await signPdf(unsignedPdf, {
      method: 'ai',
      generator: 'test',
      generatedAt: new Date().toISOString(),
      userFingerprint: 'fp',
    });
    
    const unsignedCheck = await hasPdfSignature(unsignedPdf);
    const signedCheck = await hasPdfSignature(signedResult.signedPdf);
    
    console.log(`   Unsigned PDF detected as signed: ${unsignedCheck}`);
    console.log(`   Signed PDF detected as signed: ${signedCheck}`);
    
    if (!unsignedCheck && signedCheck) {
      console.log('   âœ… PASSED: Correct detection');
      passed++;
    } else {
      console.log('   âŒ FAILED: Detection incorrect');
      failed++;
    }
  } catch (e) {
    console.log(`   âŒ FAILED: ${e}`);
    failed++;
  }
  
  // ------------------------------------------------------------------------
  // Test 4: Preserve original title and author
  // ------------------------------------------------------------------------
  console.log('\nðŸ“„ Test 4: Preserve original document metadata');
  
  try {
    const originalTitle = 'My Important Document';
    const originalAuthor = 'Jane Doe';
    
    const pdf = await PDFDocument.create();
    pdf.setTitle(originalTitle);
    pdf.setAuthor(originalAuthor);
    pdf.addPage();
    const pdfBytes = await pdf.save();
    
    const { signedPdf } = await signPdf(pdfBytes, {
      method: 'mixed',
      generator: 'collaborative-edit',
      generatedAt: new Date().toISOString(),
      userFingerprint: 'editor-001',
    });
    
    const verifiedPdf = await PDFDocument.load(signedPdf);
    const preservedTitle = verifiedPdf.getTitle();
    const preservedAuthor = verifiedPdf.getAuthor();
    
    console.log(`   Original title: "${originalTitle}"`);
    console.log(`   Preserved title: "${preservedTitle}"`);
    console.log(`   Original author: "${originalAuthor}"`);
    console.log(`   Preserved author: "${preservedAuthor}"`);
    
    if (preservedTitle === originalTitle && preservedAuthor === originalAuthor) {
      console.log('   âœ… PASSED: Metadata preserved');
      passed++;
    } else {
      console.log('   âŒ FAILED: Metadata not preserved');
      failed++;
    }
  } catch (e) {
    console.log(`   âŒ FAILED: ${e}`);
    failed++;
  }
  
  // ------------------------------------------------------------------------
  // Test 5: Sign PDF with all optional fields
  // ------------------------------------------------------------------------
  console.log('\nðŸ“„ Test 5: Sign with all optional fields');
  
  try {
    const pdfBytes = await createRealPdf('Full Metadata Test', 'Testing all fields.');
    
    const metadata: PdfSigningMetadata = {
      method: 'ai',
      generator: 'elara.desktop',
      model: 'flux-pro',
      generatedAt: new Date().toISOString(),
      userFingerprint: 'user-xyz-789',
      characterId: 'char-elara-001',
      promptHash: 'abc123def456',
    };
    
    const { signedPdf } = await signPdf(pdfBytes, metadata);
    const verification = await verifyPdf(signedPdf);
    
    console.log(`   characterId: ${verification.metadata?.characterId}`);
    console.log(`   promptHash: ${verification.metadata?.promptHash}`);
    console.log(`   model: ${verification.metadata?.model}`);
    
    if (verification.metadata?.characterId === 'char-elara-001' &&
        verification.metadata?.promptHash === 'abc123def456' &&
        verification.metadata?.model === 'flux-pro') {
      console.log('   âœ… PASSED: All optional fields preserved');
      passed++;
    } else {
      console.log('   âŒ FAILED: Optional fields missing');
      failed++;
    }
  } catch (e) {
    console.log(`   âŒ FAILED: ${e}`);
    failed++;
  }
  
  // ------------------------------------------------------------------------
  // Test 6: Save signed PDF to disk and reload
  // ------------------------------------------------------------------------
  console.log('\nðŸ“„ Test 6: Save to disk and reload');
  
  try {
    const pdfBytes = await createRealPdf('Disk Test', 'Testing file I/O.');
    
    const { signedPdf, signatureHash } = await signPdf(pdfBytes, {
      method: 'ai',
      generator: 'disk-test',
      generatedAt: new Date().toISOString(),
      userFingerprint: 'disk-fp',
    });
    
    // Save to disk
    const testFilePath = path.join(process.cwd(), 'test-files', 'test-signed.pdf');
    fs.writeFileSync(testFilePath, signedPdf);
    console.log(`   Saved to: ${testFilePath}`);
    
    // Reload from disk
    const reloadedBytes = fs.readFileSync(testFilePath);
    const verification = await verifyPdf(new Uint8Array(reloadedBytes));
    
    console.log(`   Reloaded size: ${reloadedBytes.length} bytes`);
    console.log(`   Still signed: ${verification.isSigned}`);
    
    // Clean up
    fs.unlinkSync(testFilePath);
    
    if (verification.isSigned && 
        verification.signatureHash?.startsWith(signatureHash.slice(0, 16))) {
      console.log('   âœ… PASSED: Signature survives disk I/O');
      passed++;
    } else {
      console.log('   âŒ FAILED: Signature lost after disk I/O');
      failed++;
    }
  } catch (e) {
    console.log(`   âŒ FAILED: ${e}`);
    failed++;
  }
  
  // ------------------------------------------------------------------------
  // Test 7: Content hash changes if PDF modified
  // ------------------------------------------------------------------------
  console.log('\nðŸ“„ Test 7: Content hash integrity');
  
  try {
    const pdfBytes = await createRealPdf('Hash Test', 'Original content.');
    
    const hash1 = await sha256(pdfBytes);
    
    // Create a different PDF
    const pdfBytes2 = await createRealPdf('Hash Test', 'Modified content!');
    const hash2 = await sha256(pdfBytes2);
    
    console.log(`   Hash 1: ${hash1.slice(0, 32)}...`);
    console.log(`   Hash 2: ${hash2.slice(0, 32)}...`);
    
    if (hash1 !== hash2) {
      console.log('   âœ… PASSED: Different content = different hash');
      passed++;
    } else {
      console.log('   âŒ FAILED: Hashes should differ');
      failed++;
    }
  } catch (e) {
    console.log(`   âŒ FAILED: ${e}`);
    failed++;
  }
  
  // ========================================================================
  // Summary
  // ========================================================================
  
  console.log('\n' + '='.repeat(60));
  console.log(`\nðŸ“Š Results: ${passed} passed, ${failed} failed\n`);
  
  if (failed === 0) {
    console.log('âœ… All PDF tests passed.\n');
  } else {
    console.log('âŒ Some PDF tests failed.\n');
    process.exit(1);
  }
}

runTests().catch(e => {
  console.error('Test suite error:', e);
  process.exit(1);
});
