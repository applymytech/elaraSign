#!/usr/bin/env npx tsx
/**
 * elaraSign Test Runner
 * =====================
 * 
 * Tests elaraSign by calling REAL AI APIs to generate content,
 * signing it, and verifying the signatures.
 * 
 * API keys are required. If you don't have them, this will tell you
 * how to get them. There are no fake tests or fallbacks.
 * 
 * Usage:
 *   npx tsx src/testing/test-runner.ts --together-key=YOUR_KEY
 *   npx tsx src/testing/test-runner.ts --help
 * 
 * Environment variables also work:
 *   TOGETHER_API_KEY=xxx npx tsx src/testing/test-runner.ts
 */

import { signAudio, verifyAudio, detectAudioFormat } from '../core/audio-signing.js';
import * as fs from 'node:fs';
import * as path from 'node:path';

// ============================================================================
// CLI Argument Parsing
// ============================================================================

interface TestConfig {
  togetherKey?: string;
  openaiKey?: string;
  exaKey?: string;
  verbose: boolean;
  saveArtifacts: boolean;
  outputDir: string;
}

function parseArgs(): TestConfig {
  const args = process.argv.slice(2);
  const config: TestConfig = {
    verbose: false,
    saveArtifacts: true,
    outputDir: path.join(process.cwd(), 'test-output', `run-${Date.now()}`),
  };

  for (const arg of args) {
    if (arg === '--help' || arg === '-h') {
      printHelp();
      process.exit(0);
    } else if (arg === '--verbose' || arg === '-v') {
      config.verbose = true;
    } else if (arg === '--no-save') {
      config.saveArtifacts = false;
    } else if (arg.startsWith('--together-key=')) {
      config.togetherKey = arg.split('=')[1];
    } else if (arg.startsWith('--openai-key=')) {
      config.openaiKey = arg.split('=')[1];
    } else if (arg.startsWith('--exa-key=')) {
      config.exaKey = arg.split('=')[1];
    } else if (arg.startsWith('--output=')) {
      config.outputDir = arg.split('=')[1];
    }
  }

  // Also check environment variables
  config.togetherKey = config.togetherKey || process.env.TOGETHER_API_KEY;
  config.openaiKey = config.openaiKey || process.env.OPENAI_API_KEY;
  config.exaKey = config.exaKey || process.env.EXA_API_KEY;

  return config;
}

function printHelp(): void {
  console.log(`
================================================================================
                         elaraSign Test Runner
================================================================================

Tests elaraSign with REAL AI APIs. Your API keys are used only for this
test run and are never stored.

USAGE:
  npx tsx src/testing/test-runner.ts [options]

OPTIONS:
  --together-key=KEY    Together.ai API key (for TTS audio generation)
  --openai-key=KEY      OpenAI API key (for TTS and image generation)
  --exa-key=KEY         Exa API key (for error diagnosis if tests fail)
  --verbose, -v         Show detailed output
  --no-save             Don't save test artifacts to disk
  --output=DIR          Output directory for test artifacts
  --help, -h            Show this help

ENVIRONMENT VARIABLES:
  TOGETHER_API_KEY      Alternative to --together-key
  OPENAI_API_KEY        Alternative to --openai-key
  EXA_API_KEY           Alternative to --exa-key

EXAMPLES:
  npx tsx src/testing/test-runner.ts --together-key=your_key_here
  npx tsx src/testing/test-runner.ts --together-key=xxx --openai-key=yyy
  TOGETHER_API_KEY=xxx npx tsx src/testing/test-runner.ts

GET API KEYS:
  Together.ai: https://api.together.xyz/settings/api-keys
  OpenAI:      https://platform.openai.com/api-keys
  Exa:         https://dashboard.exa.ai/api-keys

WHAT GETS TESTED:
  1. Generate audio via AI TTS API
  2. Sign that audio with elaraSign
  3. Verify signature is readable and correct
  4. Artifacts saved to test-output/ (playable audio files)

API KEY SECURITY:
  - Passed via CLI or env vars only
  - Used only during test runtime
  - Never written to disk or logs
`);
}

function printNoKeysMessage(): void {
  console.log(`
================================================================================
                         API Keys Required
================================================================================

To run tests, you need at least one API key.

QUICK START:

  1. Get a Together.ai key (free tier available):
     https://api.together.xyz/settings/api-keys

  2. Run the tests:
     npx tsx src/testing/test-runner.ts --together-key=YOUR_KEY

Or use environment variables:
     set TOGETHER_API_KEY=your_key_here
     npx tsx src/testing/test-runner.ts

OTHER PROVIDERS:
  OpenAI: https://platform.openai.com/api-keys (use --openai-key)

For more options: npx tsx src/testing/test-runner.ts --help
`);
}

// ============================================================================
// Diagnostic Logging
// ============================================================================

interface DiagnosticLog {
  timestamp: string;
  testRun: string;
  tests: TestResult[];
  errors: ErrorLog[];
  summary: {
    total: number;
    passed: number;
    failed: number;
  };
}

interface TestResult {
  name: string;
  status: 'passed' | 'failed';
  duration: number;
  details?: string;
  error?: string;
}

interface ErrorLog {
  timestamp: string;
  test: string;
  error: string;
  stack?: string;
  context?: Record<string, unknown>;
}

class TestLogger {
  private log: DiagnosticLog;
  private outputDir: string;
  private verbose: boolean;

  constructor(outputDir: string, verbose: boolean) {
    this.outputDir = outputDir;
    this.verbose = verbose;
    this.log = {
      timestamp: new Date().toISOString(),
      testRun: `run-${Date.now()}`,
      tests: [],
      errors: [],
      summary: { total: 0, passed: 0, failed: 0 },
    };
  }

  startTest(name: string): number {
    console.log(`\n[TEST] ${name}`);
    return Date.now();
  }

  pass(name: string, startTime: number, details?: string): void {
    const duration = Date.now() - startTime;
    console.log(`  [PASS] (${duration}ms)`);
    if (details && this.verbose) {
      console.log(`  ${details}`);
    }
    this.log.tests.push({ name, status: 'passed', duration, details });
    this.log.summary.passed++;
    this.log.summary.total++;
  }

  fail(name: string, startTime: number, error: Error | string, context?: Record<string, unknown>): void {
    const duration = Date.now() - startTime;
    const errorMsg = error instanceof Error ? error.message : error;
    const stack = error instanceof Error ? error.stack : undefined;
    
    console.log(`  [FAIL] (${duration}ms)`);
    console.log(`  Error: ${errorMsg}`);
    
    this.log.tests.push({ name, status: 'failed', duration, error: errorMsg });
    this.log.errors.push({
      timestamp: new Date().toISOString(),
      test: name,
      error: errorMsg,
      stack,
      context,
    });
    this.log.summary.failed++;
    this.log.summary.total++;
  }

  info(message: string): void {
    if (this.verbose) {
      console.log(`  [INFO] ${message}`);
    }
  }

  async save(): Promise<string | null> {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
    
    const logPath = path.join(this.outputDir, 'diagnostic-log.json');
    fs.writeFileSync(logPath, JSON.stringify(this.log, null, 2));
    return logPath;
  }

  printSummary(): void {
    const { total, passed, failed } = this.log.summary;
    console.log(`\n${'='.repeat(60)}`);
    console.log('\nTEST SUMMARY\n');
    console.log(`  Total:   ${total}`);
    console.log(`  Passed:  ${passed}`);
    console.log(`  Failed:  ${failed}`);
    console.log(`\n${'='.repeat(60)}`);
    
    if (failed === 0 && passed > 0) {
      console.log('\nAll tests passed.\n');
    } else if (failed > 0) {
      console.log('\nSome tests failed. See diagnostic log for details.\n');
    }
  }

  getLog(): DiagnosticLog {
    return this.log;
  }
}

// ============================================================================
// Exa Error Diagnosis (Optional Enhancement)
// ============================================================================

async function diagnoseError(
  exaKey: string | undefined,
  error: string,
  context: string
): Promise<string | null> {
  if (!exaKey) {
    return null;
  }

  try {
    const response = await fetch('https://api.exa.ai/answer', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': exaKey,
      },
      body: JSON.stringify({
        query: `How to fix this error in a Node.js TypeScript project? Error: "${error}". Context: ${context}`,
        text: true,
      }),
    });

    if (!response.ok) {
      return null;
    }

    const data = await response.json();
    return data.answer || null;
  } catch {
    return null;
  }
}

// ============================================================================
// API Calls
// ============================================================================

async function generateTogetherTTS(
  apiKey: string,
  text: string
): Promise<Uint8Array> {
  const response = await fetch('https://api.together.xyz/v1/audio/speech', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'cartesia/sonic',
      input: text,
      voice: 'helpful woman',
      response_format: 'wav',
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Together.ai API error (${response.status}): ${errorText}`);
  }

  const arrayBuffer = await response.arrayBuffer();
  return new Uint8Array(arrayBuffer);
}

async function generateOpenAITTS(
  apiKey: string,
  text: string
): Promise<Uint8Array> {
  const response = await fetch('https://api.openai.com/v1/audio/speech', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'tts-1',
      input: text,
      voice: 'alloy',
      response_format: 'mp3',
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`OpenAI API error (${response.status}): ${errorText}`);
  }

  const arrayBuffer = await response.arrayBuffer();
  return new Uint8Array(arrayBuffer);
}

// ============================================================================
// Tests
// ============================================================================

async function runTests(config: TestConfig): Promise<void> {
  // Check if we have any API keys at all
  if (!config.togetherKey && !config.openaiKey) {
    printNoKeysMessage();
    process.exit(1);
  }

  console.log('\n================================================================================');
  console.log('                         elaraSign Test Suite');
  console.log('================================================================================\n');

  const logger = new TestLogger(config.outputDir, config.verbose);

  // Ensure output directory exists
  if (config.saveArtifacts && !fs.existsSync(config.outputDir)) {
    fs.mkdirSync(config.outputDir, { recursive: true });
  }

  // ========================================================================
  // Test: Together.ai TTS -> Sign -> Verify
  // ========================================================================
  if (config.togetherKey) {
    const start = logger.startTest('Together.ai TTS -> Sign -> Verify (WAV)');
    
    try {
      // Step 1: Generate audio from API
      logger.info('Calling Together.ai TTS API...');
      const audioBytes = await generateTogetherTTS(
        config.togetherKey,
        'This audio was generated by Together AI and signed with elaraSign for content provenance.'
      );
      logger.info(`Generated ${audioBytes.length} bytes of WAV audio`);

      // Step 2: Verify it's actually WAV format
      const format = detectAudioFormat(audioBytes);
      if (format !== 'wav') {
        throw new Error(`Expected WAV format from API, got: ${format}`);
      }
      logger.info('Format confirmed: WAV');

      // Step 3: Sign the audio
      logger.info('Signing audio with elaraSign...');
      const signResult = await signAudio(audioBytes, {
        method: 'ai',
        generator: 'together-tts',
        model: 'cartesia/sonic',
        generatedAt: new Date().toISOString(),
        userFingerprint: 'test-runner',
        voiceModel: 'helpful woman',
      });
      logger.info(`Signed audio: ${signResult.signedAudio.length} bytes`);
      logger.info(`Signature hash: ${signResult.signatureHash.slice(0, 32)}...`);

      // Step 4: Verify the signature
      logger.info('Verifying signature...');
      const verifyResult = await verifyAudio(signResult.signedAudio);
      
      if (!verifyResult.isSigned) {
        throw new Error('Verification failed: signature not detected in signed audio');
      }
      if (verifyResult.metadata?.method !== 'ai') {
        throw new Error(`Method mismatch: expected 'ai', got '${verifyResult.metadata?.method}'`);
      }
      if (verifyResult.metadata?.generator !== 'together-tts') {
        throw new Error(`Generator mismatch: expected 'together-tts', got '${verifyResult.metadata?.generator}'`);
      }

      // Step 5: Save artifact
      if (config.saveArtifacts) {
        const artifactPath = path.join(config.outputDir, 'together-tts-signed.wav');
        fs.writeFileSync(artifactPath, signResult.signedAudio);
        logger.info(`Saved to: ${artifactPath}`);
      }

      logger.pass('Together.ai TTS -> Sign -> Verify (WAV)', start, 
        `Generated ${audioBytes.length} bytes, signed to ${signResult.signedAudio.length} bytes`);
      
    } catch (error) {
      logger.fail('Together.ai TTS -> Sign -> Verify (WAV)', start, error as Error, {
        provider: 'together.ai',
        endpoint: '/v1/audio/speech',
      });

      // Try Exa diagnosis if available
      if (config.exaKey) {
        console.log('  [INFO] Asking Exa for diagnosis...');
        const diagnosis = await diagnoseError(
          config.exaKey,
          (error as Error).message,
          'Together.ai TTS API call in elaraSign test'
        );
        if (diagnosis) {
          console.log(`  [HELP] ${diagnosis.slice(0, 300)}`);
        }
      }
    }
  }

  // ========================================================================
  // Test: OpenAI TTS -> Sign -> Verify
  // ========================================================================
  if (config.openaiKey) {
    const start = logger.startTest('OpenAI TTS -> Sign -> Verify (MP3)');
    
    try {
      // Step 1: Generate audio from API
      logger.info('Calling OpenAI TTS API...');
      const audioBytes = await generateOpenAITTS(
        config.openaiKey,
        'This audio was generated by OpenAI and signed with elaraSign.'
      );
      logger.info(`Generated ${audioBytes.length} bytes of MP3 audio`);

      // Step 2: Verify format
      const format = detectAudioFormat(audioBytes);
      if (format !== 'mp3') {
        throw new Error(`Expected MP3 format from API, got: ${format}`);
      }
      logger.info('Format confirmed: MP3');

      // Step 3: Sign the audio
      logger.info('Signing audio with elaraSign...');
      const signResult = await signAudio(audioBytes, {
        method: 'ai',
        generator: 'openai-tts',
        model: 'tts-1',
        generatedAt: new Date().toISOString(),
        userFingerprint: 'test-runner',
        voiceModel: 'alloy',
      });
      logger.info(`Signed audio: ${signResult.signedAudio.length} bytes`);

      // Step 4: Verify the signature
      logger.info('Verifying signature...');
      const verifyResult = await verifyAudio(signResult.signedAudio);
      
      if (!verifyResult.isSigned) {
        throw new Error('Verification failed: signature not detected');
      }

      // Step 5: Save artifact
      if (config.saveArtifacts) {
        const artifactPath = path.join(config.outputDir, 'openai-tts-signed.mp3');
        fs.writeFileSync(artifactPath, signResult.signedAudio);
        logger.info(`Saved to: ${artifactPath}`);
      }

      logger.pass('OpenAI TTS -> Sign -> Verify (MP3)', start,
        `Generated ${audioBytes.length} bytes, signed to ${signResult.signedAudio.length} bytes`);
      
    } catch (error) {
      logger.fail('OpenAI TTS -> Sign -> Verify (MP3)', start, error as Error, {
        provider: 'openai',
        endpoint: '/v1/audio/speech',
      });
    }
  }

  // ========================================================================
  // Save diagnostic log and print summary
  // ========================================================================
  if (config.saveArtifacts) {
    const logPath = await logger.save();
    console.log(`\nDiagnostic log saved to: ${logPath}`);
  }

  logger.printSummary();

  // Exit with appropriate code
  const log = logger.getLog();
  if (log.summary.failed > 0) {
    process.exit(1);
  }
}

// ============================================================================
// Main
// ============================================================================

const config = parseArgs();
runTests(config).catch((error) => {
  console.error('\nFatal error:', error);
  process.exit(1);
});
